MODULE SWARM_MOD
!===============================================================================
! MÓDULO DO MÉTODO DO PARTICLE SWARM OPTIMIZATION (PSO)
! (KENNEDY E EBERHART, 1995, IN: PROC. IEEE INTERNATIONAL CONFERENCE ON NEURAL NETWORKS, PERTH, AUSTRALIA, PP. 1942-1948)
! SCHWAAB E PINTO, 
! FUNDAMENTOS DE ESTATÍSTICA E ESTIMAÇÃO DE PARÂMETROS
! EPAPERS, RIO DE JANEIRO,2007
! SEÇÃO 5.6.4
  USE GLOBAL_MOD
  USE OBJF_MOD
  USE ZIGGURAT_MOD
!===============================================================================
  CONTAINS
!===============================================================================
  SUBROUTINE SWARM(FLAG_REGCONF,NIT,NPS,PLMIN,PLMAX,FOBJ,GL)
  !IMPLEMENTAÇÃO DO METODO PSO
  INTEGER, INTENT(IN) :: FLAG_REGCONF  ! DEFINE SE CRIA ARQUIVO PARA REGIÃO DE CONFIANÇA
  INTEGER, INTENT(IN) :: NPS      ! NÚMERO DE PARTÍCULAS NO SWARM
  INTEGER, INTENT(IN) :: NIT    ! NÚMERO DE ITERAÇÕES
  REAL(8), INTENT(IN) :: PLMIN(NPAR)  ! LIMITES INFERIOR E SUPEIOR DO INTERVALO DE BUSCA DOS PARÂMETROS
  REAL(8), INTENT(IN) :: PLMAX(NPAR)  ! LIMITES INFERIOR E SUPEIOR DO INTERVALO DE BUSCA DOS PARÂMETROS
  REAL(8), INTENT(OUT) :: FOBJ      ! VALOR FINAL DA FUNÇÃO OBJETIVO
  INTEGER, INTENT(IN) :: GL !NUMERO DE GRAUS DE LIBERDADE PARA O TESTE DE CHI QUADRADO
  !CALIBRAÇÃO DO SWARM SEGUNDO EXEMPLO 5.10
  REAL(8), PARAMETER :: WO = 0.75   ! VALOR INICIAL E FINAL DO FATOR DE INÉRCIA
  REAL(8), PARAMETER :: WF = 0.75   ! VALOR INICIAL E FINAL DO FATOR DE INÉRCIA
  REAL(8), PARAMETER :: C1 = 1.5   ! VALOR DAS PONDERAÇÕES DA CONTRIBUIÇÃO INDIVIDUAL E GLOBAL
  REAL(8), PARAMETER :: C2 = 1.5   ! VALOR DAS PONDERAÇÕES DA CONTRIBUIÇÃO INDIVIDUAL E GLOBAL
  REAL(8) :: W        ! VALOR DO FATOR DE INÉRCIA VARIÁVEL AO LONGO DA BUSCA
  INTEGER :: I
  INTEGER :: J
  INTEGER :: IT    ! CONTADOR DAS ITERAÇÕES
  INTEGER :: POS(1)  ! ARRAY1D DE UM ELEMENTO PARA SALVAR O ÍNDICE DA POSIÇÃO DO MENOR VALOR DE UM OUTRO ARRAY 1D
  REAL(8) :: P(NPS,NPAR)    ! MATRIZ COM OS VALORES DOS PARÂMETROS DE CADA PARTÍCULA
  REAL(8) :: PVEL(NPS,NPAR)  ! MATRIZ COM OS VALORES DAS VELOCIDADES DE CADA PARTÍCULA
  REAL(8) :: VMAX(NPAR)    ! VETOR COM AS VELOCIDADES MÁXIMAS EM CADA DIREÇÃO
  REAL(8) :: PPT(NPS,NPAR)  ! MATRIZ COM OS VALORES DOS PARÂMETROS ÓTIMOS DE CADA PARTÍCULA
  REAL(8) :: POTM(NPAR)    ! VETOR COM OS PARÂMETROS ÓTIMOS DO CONJUNTO DE PARTÍCULAS
  REAL(8) :: F(NPS)      ! VETOR COM OS VALORES DAS FUNÇÕES OBJETIVO DA ITERAÇÃO ATUAL DE CADA PARTÍCULA
  REAL(8) :: FPT(NPS)    ! VETOR COM OS VALORES ÓTIMOS PARTICULARES DAS FUNÇÕES OBJETIVO DE CADA PARTÍCULA
  REAL(8) :: FOTM !VALORES OTIMOS NA POPULAÇÃO DA FUNCAO OBJETIVO AO LONGO DAS ITERAÇÕES
  INTEGER :: SAIDA_SWARM_POPULACAO_FNUM
  !-----------------------------------------------------------------------------
  CALL ZIGSET( TIME()**2 ) !INICIALIZAÇÃO DO GERADOR DE NÚMEROS ALEATÓRIOS
  !SPLASH
  WRITE(*,"(/,'SWARM:')")
  !CABEÇALHO
  WRITE(*,"(T1,'ITERATION',T20,'OBJF', T30, 'PABS',T70,"//INT_TO_CHAR(NPAR)//"('PARAM(',I0,')',5X))") (I,I=1,NPAR)
  !INICIO
  IF (NPS .GT. 0) THEN
    FOTM = HUGE(1.D0)
    FPT = HUGE(1.D0)
    ! DEFINE A VELOCIDADE MÁXIMA COMO A QUE TRANSVERSA A REGIAO DE BUSCA INTEIRA EM UM UNICO PASSO
    VMAX = (PLMAX(:) - PLMIN(:))/2.D0
    ! GERANDO SWARM INICIAL E VELOCIDADES INICIAIS
    DO I=1,NPS
      DO J=1,NPAR
        !POSIÇÕES ALEATORIAMENTE (UNIFORME) ENTRE OS LIMITES INFERIOR E SUPERIOR
        P(I,J) = PLMIN(J) + UNI()*(PLMAX(J) - PLMIN(J))
        !VELOCIDADES ALEATORIAMENTE (UNIFORME) ENTRE VMAX E -VMAX
        PVEL(I,J) = VMAX(J)*(2.D0*UNI() - 1.D0)
      ENDDO
    ENDDO
      ! 1 PARTÍCULA PODE TER O VALOR TESTE DO ARQUIVO DE DADOS OPT
        DO J=1,NPAR
          P(1,J) = PARAM(J)
        ENDDO
      !ABRIR ARQUIVO DE REGIAO DE CONFIANÇA
      IF(FLAG_REGCONF .EQ. 1) THEN
        OPEN (NEWUNIT=SAIDA_SWARM_POPULACAO_FNUM,FILE='OUTPUT/SAIDA_SWARM_POPULACAO.DAT',STATUS='REPLACE',ACTION='WRITE')
      ENDIF
      !INICIO DAS ITERAÇÕS
      DO IT = 1,NIT
        DO I=1,NPS
          !PASSA VALORES DE PARAMETOR DA PARTICULA PARA A MEMORIA GLOBAL. TODO: FAZER PASSAGEM POR ARGUMENTO
          PARAM(:) = P(I,:)
          !CALCULA FUNÇÃO OBJETIVO PARA TAIS PARÂMETROS
          ! TODO: FAZER UMA FUNCTION FUNÇÃO OBJETIVO
          CALL OBJF(F(I))
        ENDDO
        IF (FLAG_REGCONF .EQ. 1) THEN
          DO I=1,NPS
            !ARQUIVO  QUE VAI SER PARSED, FORMATAÇÃO ESTRITA, SEM CABEÇALHO
            WRITE(SAIDA_SWARM_POPULACAO_FNUM,"("//INT_TO_CHAR(1+1+1+NPAR)//"(A,', '))") &
            LINT_TO_CHAR(IT),LINT_TO_CHAR(I),DSCI_TO_CHAR(F(I)),(DSCI_TO_CHAR(P(I,J)), J=1,NPAR)
          ENDDO
        ENDIF
        !PROCURAR MENOR OBJF DA ITERAÇÃO ATUAL
        POS=MINLOC(F)
        ! VERIFICA SE A MENOR OBJF  DESTA ITERAÇÃO É MENOR QUE O ÓTIMO GLOBAL ATUAL
        IF (F(POS(1)) .LT. FOTM) THEN
          ! ATUALIZA O VALOR ÓTIMA DA FUNÇÃO OBJETIVO
          FOTM=F(POS(1))
          ! ATUALIZA A POSIÇÃO ÓTIMA DOS PARAMETROS
          POTM=P(POS(1),:)
          ! ESCREVE O NOVO ÓTIMO GLOBAL NA TELA
          WRITE(*,"("//INT_TO_CHAR(1+1+1)//"(A,', '),"//INT_TO_CHAR(NPAR)//"(A,', ')"//")") &
          INT_TO_CHAR(IT), SCI_TO_CHAR(FOTM), SCI_TO_CHAR(1.D0 - DCHIDF(FOTM,DFLOAT(GL))), (SCI_TO_CHAR(POTM(J)),J=1,NPAR)
        ENDIF
        ! VERIFICA SE A MENOR FOBJ DE CADA PARTICULA DIMINUIU
        FORALL(I=1:NPS,F(I) .LT. FPT(I))
          !ATUALIZA O MINIMO PARTICULAR DE CADA PARTICULA
          FPT(I) = F(I)
          PPT(I,:) = P(I,:)
        ENDFORALL
        ! DEFINE EVOLUÇÃO PARA W, EQUAÇÃO 5.33
        W = WO + (WF-WO) * DFLOAT(IT-1) / DFLOAT(NIT-1)
        !ATUALIZAÇÃO DO SWARM
        DO I=1,NPS
          DO J=1,NPAR
            !ATUALIZAÇÃO DA VELOCIDADE, EQUAÇÃO 5.31
            !CONTRIBUIÇÃO NA DIREÇÃO ATERIOR +
            !CONTRIBUIÇÃO NA DIREÇÃO DO MELHOR INDIVIDUAL +
            !CONTRIBUIÇÃO NA DIREÇÃO DO MELHOR GLOBAL
            PVEL(I,J) = W*PVEL(I,J) + C1*UNI()*(PPT(I,J) - P(I,J)) + C2*UNI()*(POTM(J) - P(I,J))
            ! CONTROLE DE VELOCIDADE MAXIMA
            IF( ABS(PVEL(I,J)) .GT. VMAX(J) ) THEN
              PVEL(I,J) = SIGN(VMAX(J),PVEL(I,J))
            ENDIF
            ! ATUALIZA POSIÇÃO, EQUAÇÃO 5.32
            P(I,J) = P(I,J) + PVEL(I,J)
          ENDDO
        ENDDO
        ! VERIFICA SE OS LIMITES DE BUSCA FORAM ULTRAPASSADOS
        ! POSICIONA A PARTIULA NA FRONTEIRA E REDUZ A VELOCIDADE PARA A PROXIMA ITERAÇÃO
        ! LIMITE INFERIOR
        FORALL(I=1:NPS, J=1:NPAR, P(I,J) .LT. PLMIN(J))
          P(I,J) = PLMIN(J)
          PVEL(I,J) = - PVEL(I,J)/2.D0
        ENDFORALL
        !LIMITE SUPERIOR
        FORALL(I=1:NPS,J=1:NPAR, P(I,J) .GT. PLMAX(J))
          P(I,J) = PLMAX(J)
          PVEL(I,J) = - PVEL(I,J)/2.D0
        ENDFORALL
      ENDDO
      !FIM DAS ITERAÇÕES: 
      !-------------------------------------------------------------------------
      !ENCERRAMENTO
      FOBJ = FOTM
      PARAM = POTM
      IF(FLAG_REGCONF .EQ. 1) THEN
        CLOSE(SAIDA_SWARM_POPULACAO_FNUM)
      ENDIF
    ELSE
      WRITE(*,'(A)') 'NÚMERO DE PARTÍCULAS NO SWARM MENOR OU IGUAL A ZERO, SWARM IGNORADO'
    ENDIF
  ENDSUBROUTINE
ENDMODULE
