MODULE GAUSSNEWTON_MOD
!  SCHWAAB, M. PINTO, J. C. ANÁLISE DE DADOS EXPERIMENTAIS I FUNDAM
!  ENTOS DE ESTATÍSTICA E ESTIMAÇÃO DE PARÂMETROS.EPAPERS, RIO DE JANEIRO,2007
!  SEÇÃO 5.3 MÉTODO DE GAUSS-NEWTON
!  GAUSS-NEWTON (ANDERSON ET AL.,AICHE J.,1978,24(1),20-29)
!  ACELERADOR DE LAW E BAILEY (LAW & BAILEY,CHEM.ENG.SCI.,1963,18,189-202)
  USE GLOBAL_MOD
  USE OBJF_MOD
!===============================================================================
  CONTAINS
!===============================================================================
  SUBROUTINE GAUSSNEWTON(NIT,FTOL,ALPHA_LB_TOL,PLMIN,PLMAX,DP,IT,FOBJ,COVPAR,COVPRED)
    !MINIMIZAÇÃO DA FUNÇAO OBJETIVO USANDO O METODO DE NEWTON COM
    !METODO DE ANALISE DE CONVERGENCIA DE LAW E BAILEY
    !USANDO A APROXIMAÇAO DE GAUSS PARA A MATRIZ HESSIANA (GAUSS-NEWTON)
    !ANDERSON ET AL.,AICHE J.,1978,24(1),20-29
    !LAW & BAILEY 1963, SEÇÃO (E)
    INTEGER :: I
    INTEGER :: K
    INTEGER :: M
    REAL(8) :: AUX
    INTEGER, INTENT(IN) :: NIT   ! NÚMERO MÁXIMO DE ITERAÇÕES
    !LAW & BAILEY
    REAL(8), PARAMETER :: R_LB = 2.    ! FATOR DE REDUÇÃO NA LIMITAÇÃO DO PASSO DOS PARAMETROS, FIG 6, BLOCO 15
    REAL(8), PARAMETER :: BETA_LB = 0.25   ! PARÂMETRO DE CRITÉRIO DE ACELEREÇÃO LAW & BAILEY, FIG6, BLOCO 14, EQ 27,
    REAL(8) :: ALPHA_LB    ! FATOR DE LIMITAÇÃO DE PASSO, COMEÇA COMO 1 E DIMINUI COMO ALPHA_LB/2
    !GAUSSNEWTON
    REAL(8), INTENT(IN) :: FTOL    ! TOLERÂNCIA RELATIVA PARA A FUNÇÃO OBJETIVO
    REAL(8), INTENT(IN) :: ALPHA_LB_TOL  ! TOLERÂNCIA ABSOLUTA NO PASSO NOS PARAMETROS
    REAL(8), INTENT(IN) :: PLMIN(NPAR)  ! FAIXA VÁLIDA DOS PARÂMETROS: MINIMO
    REAL(8), INTENT(IN) :: PLMAX(NPAR)  ! FAIXA VÁLIDA DOS PARÂMETROS: MAXIMO
    REAL(8), INTENT(IN) :: DP(NPAR)      ! PERTURBAÇÃO RELATIVA NOS PARÂMETROS
    INTEGER, INTENT(OUT) :: IT        ! NÚMERO ITERAÇÕES REALIZADAS
    REAL(8), INTENT(OUT) :: FOBJ      ! VALOR DA FUNÇÃO OBJETIVO
    REAL(8), INTENT(OUT) :: COVPAR(NPAR,NPAR)  ! MATRIZ DE COVARIÂNCIA DOS PARÂMETROS
    TYPE(M3_LIST), ALLOCATABLE, INTENT(OUT) :: COVPRED(:) !(NEXP,NSAI,NSAI)! MATRIZ DE COVARIÂNCIA DE PREDIÇÃO
    TYPE(M3_LIST), ALLOCATABLE :: DYCDP(:) !(NEXP,NSAI,NPAR)! DERIVADAS DA SAÍDA DO MODELO EM RELAÇÃO AOS PARÂMETROS
                                         !MATRIZ DE SENSITIVIDADES "B" EQ 4.78, EXEMPLO 5.1
                                         !DERIVADAS DE YC EM RELAÇÃO A PAR
    TYPE(M2_LIST), ALLOCATABLE :: EY(:) !(NEXP,NSAI)! DESVIOS DAS VARIÁVEIS DE SAÍDA: ERRO YC-YE
    REAL(8) T(NPAR,NPAR) !     ! 0.5D0 VEZES A APROXIMAÇÃO DE GAUSS PARA A MATRIZ HESSIANA DA FUNÇÃO OBJETIVO EM RELAÇÃO AOS PARAMETROS (D2FDP2), EXEMPLO 5.1 VS EQ 5.12
    REAL(8) TINV(NPAR,NPAR)      ! INVERSA DE T
    REAL(8) U(NPAR)          ! VETOR 0.5D0 VEZES GRADIENTE DA FUNÇÃO OBJETIVO EM RELAÇÃO AOS PARAMETROS (DFDP), EXEMPLO 5.1 VS EQ 5.12
    REAL(8) STEPP(NPAR)    ! INCREMENTO NOS PARÂMETROS
    REAL(8) FOBJN  ! VALOR ATUALIZADO DA FUNÇÃO OBJETIVO
!    REAL(8) PARAMN  ! VALOR ATUALIZADO DOS APRAMETROS !TODO SÓ VAI SER ÚTIL DPS QUE O OBJF RECEBER OS PARAM VIA ARG
    REAL(8) DFL    ! INCREMENTO TOTAL NA FUNÇÃO OBJETIVO CONSIDERANDO LINEAR E SEM RESTRIÇOES DE LAW & BAILEY (FLIN(P+STEPP) - F(P)), DT, EQ 22
    REAL(8) DF    ! DELTA DA FUNÇÃO OBJETIVO REAL (F(P+STEPP) - F(P))
    INTEGER :: SAIDA_GAUSSNEWTON_FNUM !NUMERO DE ARQUIVO PARA O HISTORICO DO GAUSS NEWTON
    CHARACTER(LEN=200) :: FORMATSTR
    !SPLASH
    WRITE(*,"(/,'GAUSS-NEWTON:')")
    !ALOCAÇÃO DE MEMORIA LOCAL
    ALLOCATE(COVPRED(NMOD))
    ALLOCATE(EY(NMOD))
    ALLOCATE(DYCDP(NMOD))
    DO M = 1, NMOD
      ALLOCATE(COVPRED(M)%M(NEXP(M),NSAI(M),NSAI(M)))
      ALLOCATE(EY(M)%M(NEXP(M),NSAI(M)))
      ALLOCATE(DYCDP(M)%M(NEXP(M),NSAI(M),NPAR))
    ENDDO
    !INICIALIZAÇÃO ARQUIVO
    ! ARQUIO DE SAIDA DOS DADOS OBTIDOS AO LONGO DAS ITERAÇÕES
    OPEN (NEWUNIT=SAIDA_GAUSSNEWTON_FNUM,FILE='OUTPUT/SAIDA_GAUSSNEWTON.DAT',STATUS='REPLACE',ACTION='WRITE')
    !---------------------------------------------------------------------------
    ! INICIO DAS ITERAÇÕES
    !---------------------------------------------------------------------------
    IT=0
    ! CÁLCULO DA FUNÇÃO OBJETIVO
    CALL OBJF(FOBJ)
    !LOOP DO METODO DE NEWTON
    DO !GAUSSNEWTON
      ! ESCREVE OS RESULTADOS INTERMEDIÁRIOS
      FORMATSTR="(/,2X,'ITERACAO ',I4)"
      WRITE(*,FORMATSTR)                      IT
      WRITE(SAIDA_GAUSSNEWTON_FNUM,FORMATSTR) IT
      ! ADICIONA UMA ITERAÇÃO
      IT=IT+1
      ! INICIALIZAÇÃO DO PARAMETRO DE ALW & BAILEY PARA LIMITAÇÃO DO PASSO
      ALPHA_LB=1.D0
      ! CÁLCULO DOS DESVIOS DAS VARIÁVEIS (CALCULADO - EXPERIMENTAL, CONVENÇÃO DE SINAIS INVERSA AO LIVRO, )
      DO M = 1, NMOD
        EY(M)%M(:,:)=YC(M)%M(:,:)-YE(M)%M(:,:)
      ENDDO
      ! CÁLCULO DAS PRIMEIRAS DERIVADAS DO MODELO
      CALL JACOBIAN(DP,DYCDP)
      !-------------------------------------------------------------------------
      ! APROXIMAÇÃO DE GAUSS
      !-------------------------------------------------------------------------
      ! CÁLCULO DA MATRIZ T[NPAR,NPAR]
      ! HALPHA/2 = BT VY^-1 B, EQ. 4.77
      T=0.D0
      DO M = 1, NMOD
        DO K=1,NEXP(M)
          T = T + MATMUL(TRANSPOSE(DYCDP(M)%M(K,:,:)),MATMUL(VARYEINV(M)%M(K,:,:),DYCDP(M)%M(K,:,:)))
        ENDDO
      ENDDO
      CALL INVERSAOMATRICIAL(NPAR,T,TINV)
      !-------------------------------------------------------------------------
      ! METODO DE NEWTON
      !-------------------------------------------------------------------------
      ! CÁLCULO DO VETOR U[NPAR]
      !                        B^T                    VY^-1               YI^E-FI^0, EXEMPLO 5.1; FI^0 É O VALOR CALCULADO COM UMA ESTIMATIVA DE PARAMETRO
      U=0.D0
      DO M = 1, NMOD
        DO K=1,NEXP(M)
          U = U + MATMUL(TRANSPOSE(DYCDP(M)%M(K,:,:)),MATMUL(VARYEINV(M)%M(K,:,:),EY(M)%M(K,:)))
        ENDDO
      ENDDO
      ! CÁLCULO DO INCREMENTO NOS PARÂMETROS STEPP[NPAR]
      !PASSO, EXEMPLO 5.1, EQ 5.12 DO METODO DE NEWTON
      STEPP = -MATMUL(TINV,U)


      if (useLB) then
      !-------------------------------------------------------------------------
      ! MÉTODO LAW & BAILEY PARA VERIFICAR CONVERGENCIA E ACELARAÇÃO
      !-------------------------------------------------------------------------
      ! CALCULO DA VARIAÇÃO DA FUNÇÃO OBJETIVO LINEARIZADA DT, EQ 22, CALCULADO COM BASE  NAS EQ 21, 18, 16, 15
      DFL=0.D0
      DO M = 1, NMOD
        DO K=1,NEXP(M)
          !OBTEM ESTIMATIVA DE FOBJ COM OS YCALC NOVOS
          DFL=DFL + DOT_PRODUCT(EY(M)%M(K,:),MATMUL(VARYEINV(M)%M(K,:,:),MATMUL(DYCDP(M)%M(K,:,:),STEPP(:))))
          !CONFERIDO COM MODELO REGRESSÃO LINEAR (ESPERADA = REALIZADA)
        ENDDO
      ENDDO
    
      !CORRIGE A DIREÇÃO DA BUSCA SE NECESSÁRIO: LAW & BAILEY, SEÇÃO (E), CRITERIO 1
      IF (DFL > 0.D0) THEN
        DFL=-DFL
        STEPP=-STEPP
      ENDIF
      
      !REPORT PASSO NOS PARÂMETROS
      WRITE(*,"(2X,"//"'VARIACAO DOS PARAMETROS :',"//TRIM(INT_TO_CHAR(NPAR))//"(/,'PAR',I0.0,2X,E12.6,' + (',E12.6,') = ',E12.6))") &
        (I, PARAM(I), STEPP(I), PARAM(I)+STEPP(I), I=1,NPAR)
      WRITE(SAIDA_GAUSSNEWTON_FNUM,"(2X,"//"'VARIACAO DOS PARAMETROS :',"//TRIM(INT_TO_CHAR(NPAR))//"(/,'PAR',I0.0,2X,E12.6,' + (',E12.6,') = ',E12.6))") &
        (I, PARAM(I), STEPP(I), PARAM(I)+STEPP(I), I=1,NPAR)

      !REPORT VARIAÇÃO ESPERADA NA OBFJ
      WRITE(*,"(2X,'VARIACAO ESPERADA DA FOBJ : ',2X,E12.6,' + (',E12.6,') = ',E12.6)") &
        FOBJ,DFL,FOBJ+DFL
      WRITE(SAIDA_GAUSSNEWTON_FNUM,"(2X,'VARIACAO ESPERADA DA FOBJ : ',2X,E12.6,' + (',E12.6,') = ',E12.6)") &
        FOBJ,DFL,FOBJ+DFL

      !TESTE DE RESPEITO AOS LIMITES IMPOSTOS NOS PARÂMETROS
      I = 1
      DO
        AUX = PARAM(I) + ALPHA_LB*STEPP(I)
        IF((AUX > PLMIN(I)) .AND. (AUX < PLMAX(I))) THEN
          I = I + 1
        ELSE
          ALPHA_LB = ALPHA_LB/R_LB
          IF (ALPHA_LB < ALPHA_LB_TOL) THEN
            WRITE(*,*) '(AUX > LIM(I,1)) .AND. (AUX < LIM(I,2)) RETURNS FALSE'
            WRITE(*,*) 'STEPP NA GAUSSNEWTON MUITO GRANDE'
            WRITE(*,*) 'UM LIMITE DOS PARAMETROS ESTA SENDO ULTRAPASSADO'
            STOP
          ENDIF
        ENDIF
        IF (I > NPAR) EXIT
      ENDDO
      
      !CORREÇÃO DOS VALORES DAS VARIÁVEIS DE BUSCA
      !ALPHA_LB COMEÇA COM 1.
      PARAM = PARAM + ALPHA_LB*STEPP
      !VERIFICA SE CHEGOU EM UM MÍNIMO
      CALL OBJF(FOBJN)
      FORMATSTR = "(2X,'VARIACAO REALIZADA DA FOBJ : ',2X,E12.6,' + (',E12.6,') = ',E12.6)"
      WRITE(*,FORMATSTR) FOBJ,FOBJN-FOBJ,FOBJN
      WRITE(SAIDA_GAUSSNEWTON_FNUM,FORMATSTR) FOBJ,FOBJN-FOBJ,FOBJN
      IF ( (DABS(FOBJN-FOBJ)/FOBJN < FTOL)) THEN
        !OBTIDA CONVERGENCIA (CRITERIO RELATIVO) NA FOBJ
        FOBJ=FOBJN
        EXIT
      ENDIF
      ! CONTROLE DE CONVERGÊNCIA DE LAW&BAILEY
      DO !LAW&BAILEY
        FORMATSTR = "(2X,'ALPHA_LB, FOBJN:',2X,E12.6,E12.6)"
        WRITE(SAIDA_GAUSSNEWTON_FNUM,FORMATSTR) ALPHA_LB, FOBJN
        ! CALCULA A VARIAÇÃO REAL NA FUNÇÃO OBJETIVO
        DF=FOBJN-FOBJ
        !VERIFICA SE HA CONVERGÊNCIA PARA UM MÍNIMO
        !FOBJ DIMINUI   !CRITERIO DE L&B
        !LAW & BAILEY 1963, CRITERIO 2, EQ (25), CONVEÇÃO DE SINAIS INVERTIDA
        IF (DF .LT. 0.D0) THEN
          !'DF .LT. 0.D0, FUNÇÃO OBJETIVO DIMINUINDO'
          !LAW & BAILEY 1963, CRITERIO 3, EQ (27), CONVEÇÃO DE SINAIS INVERTIDA; FIG 6, BLOCO 14
          IF(DF-BETA_LB*(2.D0*ALPHA_LB-ALPHA_LB**2)*DFL .LT. 0.D0) THEN
            !'(DF-BETA_LB*(2.D0*ALPHA_LB-ALPHA_LB**2)*DFL < 0.D0), PASSA NO CRITERIO DE ACELERAÇÃO DE LB'
            !ATUALIZA VALOR ACEITO DA FUNCAO OBJETIVO
            FOBJ=FOBJN
            !SAI DO LAW & BAILEY
            EXIT 
          ELSE
            WRITE(*,'(A)') 'CRITERIO DE LB ATIVADO (ACELERAÇÃO)'
          ENDIF
        ELSE
          WRITE(*,'(A)') 'CRITERIO DE LB ATIVADO (FREIO)'
        ENDIF
        
        !CRITÉRIO DE LAW&BAILEY ATIVADO
        !REBOBINA ! TODO: EM VEZ DE REBOBINAR, ADIAR APLICAÇÃO DA ATUALIZAÇÃO DO PARAMETRO
        PARAM = PARAM - ALPHA_LB*STEPP
        !REDUZ-SE O TAMANHO DO PASSO E CALCULA-SE OS NOVOS VALORES
        ALPHA_LB=ALPHA_LB/R_LB
        WRITE(*,"(2X,'REDUCAO DE PASSO (ALPHA_LB) =',E12.6,5X,'NOVA FUNCAO OBJETIVO =',E12.6)") &
        ALPHA_LB, FOBJN
        ! 1 -> 1/2 -> 1/2/2 -> ...
        IF (ALPHA_LB .LT. ALPHA_LB_TOL) THEN
          WRITE(*,*) '(ALPHA_LB < ALPHA_LB_TOL):'
          WRITE(*,*) 'METODO LAW & BAILEY NAO CONVERGIU'
          STOP
        ENDIF
        !AVANÇA
        PARAM = PARAM + ALPHA_LB*STEPP
        ! RECALCULAR FUNÇÃO OBJETIVO
        CALL OBJF(FOBJN)
      ENDDO !LAW&BAILEY

      else !not useLB
        PARAM = PARAM + STEPP
	
        CALL OBJF(FOBJN)

	print*, PARAM, '-->', FOBJN

        IF ( (DABS(FOBJN-FOBJ)/FOBJN < FTOL)) THEN
          !OBTIDA CONVERGENCIA (CRITERIO RELATIVO) NA FOBJ
          FOBJ=FOBJN
          EXIT
        ENDIF
	FOBJ=FOBJN
      endif !useLB

      IF (IT .GE. NIT) THEN
        WRITE(*,*) '(IT .GE. NIT)'
        WRITE(*,*) 'O NUMERO MAXIMO DE ITERACOES NA GAUSSNEWTON/LAWBAILEY FOI EXCEDIDO'
        STOP
      ENDIF
    ENDDO !GAUSSNEWTON
      !-------------------------------------------------------------------------
      ! CÁLCULO DA MATRIZES DE COVARIÂNCIA DOS PARAMETROS E DE PREDIÇÃO
      ! RECALCULAR USANDO O STEP NOS PARÂMETROS RESTRITO
      !-------------------------------------------------------------------------
      CALL JACOBIAN(DP,DYCDP)!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
      T=0.D0!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
      DO M = 1, NMOD!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
        DO K=1,NEXP(M)!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
        !EXEMPLO 5.1V ! TODO DE NOVO ISSO AQUI!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
          T = T + MATMUL(TRANSPOSE(DYCDP(M)%M(K,:,:)),MATMUL(VARYEINV(M)%M(K,:,:),DYCDP(M)%M(K,:,:)))!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
        ENDDO!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
      ENDDO!TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
      ! CÁLCULO DA INVERSA DE T[NPAR,NPAR]
      CALL INVERSAOMATRICIAL(NPAR,T,TINV) !TODO APROVEITAR CALCULOS ACIMA OU FUNCIONALIZAR E REUTILIZAR IMPLEMENTAÇÃO
    ! MATRIZ DE COVARIÂNCIA DOS PARÂMETROS
    !VALPHA, EQ. 4.82
      COVPAR = TINV
    ! MATRIZ DE COVARIANCIA DE PREDIÇÃO, VY, EQ 4.56
      DO M = 1, NMOD
        DO K=1,NEXP(M)
          COVPRED(M)%M(K,:,:)=MATMUL(DYCDP(M)%M(K,:,:),MATMUL(COVPAR,TRANSPOSE(DYCDP(M)%M(K,:,:))))
        ENDDO
      ENDDO
    !---------------------------------------------------------------------------
    !ENCERRAMENTO
    !---------------------------------------------------------------------------
    ! FECHAR ARQUIVO DE SAIDA DOS DADOS
    CLOSE (SAIDA_GAUSSNEWTON_FNUM)
    ! LIBERAÇÃO MEMORIA
    DO M = 1, NMOD
      DEALLOCATE(DYCDP(M)%M)
      DEALLOCATE(EY(M)%M)
    ENDDO
    DEALLOCATE(DYCDP)
    DEALLOCATE(EY)
  ENDSUBROUTINE
!===============================================================================
  SUBROUTINE JACOBIAN(DP,DYCDP)
    ! CÁLCULO DAS DERIVADAS DO MODELO COM RELAÇÃO AOS PARÂMETROS  !
    REAL(8), INTENT(IN) :: DP(NPAR)    ! PERTURBAÇÕES PARA O CÁLCULO DAS DERIVADAS
    TYPE(M3_LIST), INTENT(INOUT) :: DYCDP(:) ! DERIVADAS EM RELAÇÃO A PARÂMETROS
    REAL(8), ALLOCATABLE :: AUX1(:) ! MEMORIA AUXILIAR, ALOCAÇÃO AUTOMÁTICA
    REAL(8), ALLOCATABLE :: AUX2(:) ! MEMORIA AUXILIAR, ALOCAÇÃO AUTOMÁTICA
    REAL(8) :: PARD(NPAR)  !PARAMETROS COM PERTURBAÇÃO
    ! VARIÁVEIS LOCAIS
    INTEGER :: I
    INTEGER :: K
    INTEGER :: M
    ! INICIALIZANDO O VETOR COM OS PARÂMETROS PERTURBADOS
    PARD=PARAM
    DO M = 1, NMOD
      DO K=1,NEXP(M)
        DO I=1,NPAR
          ! CALCULA VARIAVEIS DE SAIDA DO MODELO COM PARAMETROS PERTURBADOS
          PARD(I)=PARAM(I)+DP(I)
          AUX1=ZEROS(NSAI(M))
          CALL PMODELS(M=M,VENT=XE(M)%M(K,:),VSAI=AUX1,PARS=PARD,GUESS=YE(M)%M(K,:))
          PARD(I)=PARAM(I)-DP(I)
          AUX2=ZEROS(NSAI(M))
          CALL PMODELS(M=M,VENT=XE(M)%M(K,:),VSAI=AUX2,PARS=PARD,GUESS=YE(M)%M(K,:))
          !RESTAURA VALORES CENTRAIS PARA O VETOR DE PARAMETROS PERTURBADO
          PARD(I)=PARAM(I)
          ! CALCULA A DERIVADA DO MODELO COM RELAÇÃO A CADA PARÂMETRO
          DYCDP(M)%M(K,:,I)=(AUX1-AUX2)/(2.D0*DP(I))
        ENDDO
      ENDDO
    ENDDO
  ENDSUBROUTINE
!===============================================================================
  SUBROUTINE INVERSAOMATRICIAL(ND,M,INVM)
  ! CÁLCULO DA INVERSA DE UMA MATRIZ
  ! USANDO O MÉTODO DE ELIMINAÇÃO DE GAUSS COM PIVOTAÇÃO PARCIAL
  INTEGER, INTENT(IN)  :: ND      ! DIMENSÃO DAS MATRIZES
  REAL(8), INTENT(IN)  :: M(:,:)  ! MATRIZ ORIGINAL
  REAL(8), INTENT(OUT) :: INVM(:,:)  ! MATRIZ INVERTIDA
  INTEGER :: I
  INTEGER :: J
  REAL(8) :: A(ND,2*ND)
  REAL(8) :: B(2*ND)
  REAL(8) :: AUX
  ! INICIALIZANDO A MATRIZ A <-- [M]
    A = 0.D0
    A(1:ND,1:ND) = M
    FORALL (I=1:ND)
      A(I,I+ND) = 1.D0
    ENDFORALL
  ! INICIO DO PROCEDIMENTO DE INVERSÃO
    DO I = 1,ND
      AUX = A(I,I)
      DO J = I+1,ND
        IF (DABS(A(J,I)) <= DABS(AUX)) THEN
          CYCLE
        ENDIF
        B(:) = A(J,:)
        A(J,:) = A(I,:)
        A(I,:) = B(:)
        AUX = A(I,I)
      ENDDO
      ! VERIFICA A POSSIBILIDADE DA MATRIZ SER NÃO INVERSÍVEL
      IF (DABS(AUX) < 1.D-10) THEN
        WRITE(*,*) '(DABS(AUX) < 1.D-10): MATRIZ NAO INVERSIVEL'
      ENDIF
      ! CONTINUA
      A(I,:) = A(I,:)/AUX
      DO J = 1,ND
        IF (I == J) THEN
          CYCLE
        ENDIF
        AUX = A(J,I)
        A(J,:) = A(J,:) - AUX*A(I,:)
      ENDDO
    ENDDO
  ! RESULTADO MATRIZ INVERSA: A --> [INVM]
    INVM = A(:,ND+1:2*ND)
  ENDSUBROUTINE
!===============================================================================
ENDMODULE
